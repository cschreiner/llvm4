; don't run this test until we get the lit commands sorted out.
; RUN: false
; XFAIL:
; END.
; =======================================================================

; RUN: %lli -force-interpreter %s | FileCheck

; TESTDRIVER-BASED: failure expected
;; Failure is expected because the last printf(~) prints a poison value.
; XFAIL: * 
; TODO: add CHECK: lines here for FileCheck


; TODO: find some way to add lit code here to run this, and compare
;	its printed output against an expected value... which may be
;	affected by the intent that a poisoned value should crash this 
;	program when output.

; Description:

; Test logical and capabilities, which should run the same as bitwise
; and, except under the "Nuno" proposal, which separates out 1-bit
; values for the special logical treatment.  Tests run twice under
; conditions should not generate poision, once under conditions that
; would generate poison if banned (but it isn't banned), once that
; generates poison.

; Declare the printf() control strings as global constants.
@unpoison_st = private unnamed_addr constant [21 x i8] c"unpoisoned: '0x%x' \0A\00"
@poison_st = private unnamed_addr constant [19 x i8] c"poisoned: '0x%x' \0A\00"

; External declaration of the puts function
declare i32 @printf(i8* nocapture readonly, ...)

; Definition of main function
define i32 @main() {   ; i32()*
  ; Convert [19 x i8]* to i8  *...
  %unpoison_st_i8 = getelementptr [21 x i8], [21 x i8]* @unpoison_st, i64 0, i64 0
  %poison_st_i8 = getelementptr [19 x i8], [19 x i8]* @poison_st, i64 0, i64 0

  ;; verify that no poison in means no poison out
  %unpoisoned0= and i1 0, 0
  %unpoisoned1= and i1 0, 1
  %unpoisoned2= and i1 1, 0
  %unpoisoned3= and i1 1, 1
  call i32 (i8*, ...) @printf(i8* %unpoison_st_i8, i8 %unpoisoned0 )
  call i32 (i8*, ...) @printf(i8* %unpoison_st_i8, i8 %unpoisoned1 )
  call i32 (i8*, ...) @printf(i8* %unpoison_st_i8, i8 %unpoisoned2 )
  call i32 (i8*, ...) @printf(i8* %unpoison_st_i8, i8 %unpoisoned3 )

  ;; verify that short circuit evaluation eliminates poison
  %poisoned_0= add nsw nuw i1 1, 1 ; should be 0
  %poisoned_1= add nsw nuw i1 1, %poisioned_0 ; should be 1
  %short_circuit1= and i1 0, %poisoned_1
  %short_circuit2= and i1 %poisoned_1, 0

  ; test for poison by passing to external ftn
  call i32 (i8*, ...) @printf(i8* %unpoison_st_i8, i8 %short_circuit1 )
  call i32 (i8*, ...) @printf(i8* %unpoison_st_i8, i8 %short_circuit2 )

  ; and what happens when poison can't be short circuit eliminated
  %poison_result= and i1 1, %poisoned_0
  call i32 (i8*, ...) @printf(i8* %poison_st_i8, i8 %poison_result )

  ; TODO: test other scenarios where poison should be generated by 1 bit ands

  ; clean up and return
  ret i32 0
}

